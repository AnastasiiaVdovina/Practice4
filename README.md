# Практичне заняття №4
## Завдання 1
### Умова
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

### Рішення
Щоб визначити, яку максимальну кількість пам'яті може виділити malloc() за один виклик, я написала [програму](https://github.com/AnastasiiaVdovina/Practice4), яка намагається виділити спочатку кількість пам'яті рівну SIZE_MAX з бібліотеки limits.h. Далі, якщо пам'ять виділити не вдається, то розмір, який передається в наступній ітерації це size /= 2. І так до моменту, поки не вдасться виділити пам'ять. Резульатати виконання роботи на 64-біній системі:

![image](https://github.com/user-attachments/assets/6397e409-57cb-4659-81c4-e1219e5d3fce)

Теоретично максимальний обсяг пам’яті, який можна передати у malloc(size_t size), дорівнює 2⁶⁴ байтів (16 ексабайт) на 64-бітних системах, оскільки size_t займає 64 біти. Однак на практиці malloc(3) може виділяти не більше 8 ЕБ, а не 16 ЕБ, через архітектурні та системні обмеження. В сучасних x86_64 процесорах використовується лише 48 або 57 біт адресації, а решта бітів зарезервовані для майбутніх оновлень, що обмежує доступний простір до 8 ексабайт (2⁶³ байт), оскільки один біт використовується для представлення знакових значень у механізмі адресації. Додатково ядро ОС накладає обмеження на максимальний розмір адресного простору для одного процесу, а malloc() витрачає частину пам’яті на метаінформацію.
У 32-бітній архітектурі (x86) size_t займає лише 4 байти, тому максимальний запит malloc() обмежується 4 ГБ (2³² байти). Таким чином, хоча теоретично malloc(3) міг би виділяти до 16 ЕБ, на практиці це обмежено 8 ЕБ через архітектурні та операційні обмеження.

## Завдання 2
### Умова
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

### Рішення
Я написала [прогаму](https://github.com/AnastasiiaVdovina/Practice4/blob/main/task2.c), яка демонструє переповнення, та працює наступним чином:
num = INT_MAX * 2 призведе до переповнення знакової змінної int, тому num стане від’ємним значенням.
При передачі num у malloc(num), від’ємне значення буде неявно перетворене у беззнаковий size_t, що дасть дуже велике значення, близьке до UINT_MAX + 1.
malloc() намагатиметься виділити величезний обсяг пам’яті, що, зазнає невдачі та поверне NULL.
Як результат:

![image](https://github.com/user-attachments/assets/e8eeacae-fc11-48ea-8d85-2362963adcf0)

Функція malloc(size_t size) приймає беззнакове значення size_t. Якщо передати від’ємне число у malloc(), воно неявно перетвориться на велике позитивне число, оскільки від'ємне значення буде трактуватися як беззнакове (unsigned) після приведення типів. Це може спричинити спробу виділити величезний блок пам’яті, що швидше за все провалиться.

## Завдання 3
### Умова
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

### Рішення

![image](https://github.com/user-attachments/assets/52f653d6-05ba-41bc-ad93-b11113653ac1)

## Завдання 4
### Умова

### Рішення


## Завдання 5
### Умова

### Рішення

## Завдання 6
### Умова

### Рішення

## Завдання 7
### Умова

### Рішення

## Завдання 8(Індивідуальне завдання)
### Умова

### Рішення
