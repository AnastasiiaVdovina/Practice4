# Практичне заняття №4
## Завдання 1
### Умова
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

### Рішення
Щоб визначити, яку максимальну кількість пам'яті може виділити malloc() за один виклик, я написала [програму](https://github.com/AnastasiiaVdovina/Practice4), яка намагається виділити спочатку кількість пам'яті рівну SIZE_MAX з бібліотеки limits.h. Далі, якщо пам'ять виділити не вдається, то розмір, який передається в наступній ітерації це size /= 2. І так до моменту, поки не вдасться виділити пам'ять. Резульатати виконання роботи на 64-біній системі:

![image](https://github.com/user-attachments/assets/6397e409-57cb-4659-81c4-e1219e5d3fce)

Теоретично максимальний обсяг пам’яті, який можна передати у malloc(size_t size), дорівнює 2⁶⁴ байтів (16 ексабайт) на 64-бітних системах, оскільки size_t займає 64 біти. Однак на практиці malloc(3) може виділяти не більше 8 ЕБ, а не 16 ЕБ, через архітектурні та системні обмеження. В сучасних x86_64 процесорах використовується лише 48 або 57 біт адресації, а решта бітів зарезервовані для майбутніх оновлень, що обмежує доступний простір до 8 ексабайт (2⁶³ байт), оскільки один біт використовується для представлення знакових значень у механізмі адресації. Додатково ядро ОС накладає обмеження на максимальний розмір адресного простору для одного процесу, а malloc() витрачає частину пам’яті на метаінформацію.
У 32-бітній архітектурі (x86) size_t займає лише 4 байти, тому максимальний запит malloc() обмежується 4 ГБ (2³² байти). Таким чином, хоча теоретично malloc(3) міг би виділяти до 16 ЕБ, на практиці це обмежено 8 ЕБ через архітектурні та операційні обмеження.

## Завдання 2
### Умова
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

### Рішення
Я написала [прогаму](https://github.com/AnastasiiaVdovina/Practice4/blob/main/task2.c), яка демонструє переповнення, та працює наступним чином:
num = INT_MAX * 2 призведе до переповнення знакової змінної int, тому num стане від’ємним значенням.
При передачі num у malloc(num), від’ємне значення буде неявно перетворене у беззнаковий size_t, що дасть дуже велике значення, близьке до UINT_MAX + 1.
malloc() намагатиметься виділити величезний обсяг пам’яті, що, зазнає невдачі та поверне NULL.
Як результат:

![image](https://github.com/user-attachments/assets/e8eeacae-fc11-48ea-8d85-2362963adcf0)

Функція malloc(size_t size) приймає беззнакове значення size_t. Якщо передати від’ємне число у malloc(), воно неявно перетвориться на велике позитивне число, оскільки від'ємне значення буде трактуватися як беззнакове (unsigned) після приведення типів. Це може спричинити спробу виділити величезний блок пам’яті, що швидше за все провалиться.

## Завдання 3
### Умова
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

### Рішення
Для демонстрації рішення я написала коротку [програму](https://github.com/AnastasiiaVdovina/Practice4/blob/main/task3.c), де розглядається 2 випадки виділення пам'яті. Перший - випадок, коли ми намагаємося виділити всього навсього 6 байт пам'яті. Пам'ять виділяється успішно, і malloc() повертає вказівник, який ми можемо передати і власне передаємо у free(). 2 випадок - намагаємося передати SIZE_MAX з бібліотеки limits.h у якості аргументу для malloc(). Пам'ять виділити не вдається, і ми отримуємо NULL. Вивід результатів роботи програми на скріні нижче.

![image](https://github.com/user-attachments/assets/049c28f1-d53f-4a21-8bea-20bfeca77df6)

## Завдання 4
### Умова
Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    ... <використання 'ptr'> ...
    free(ptr);
}

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

### Рішення
Поданий приклад коду демонструє проблему висячого вказівника (dangling pointer або use after free) . В цьому репозиторії є 2 файли з завданням 4: 1 - неправилний варіант використання, тобто як у прикладі, а інший - правильний, виправлений. 
Перша програма працює наступним чином:

![image](https://github.com/user-attachments/assets/d1ba9755-d849-4e39-aeb2-5e42160f3d51)

Як бачимо, програма використовує одну і ту ж адресу, і це нормально. АЛЕ: free(ptr) звільняє пам'ять, на яку вказує ptr, але не змінює значення самого покажчика ptr. Він все ще містить адресу щойно звільненої пам'яті (стає "висячим" покажчиком). І на наступній ітерації, цей ptr не обов'язково дорівнює NULL, тому записувати щось туди знову є небезпечним.

Як це виправити?
Додати рядок "ptr = NULL" після "free(ptr)"(це теж реалізовано в task42).
Або альтернативно використовувати пам'ять інакше, і старатися не використовувати ожну і ту є комірку пам'яті, якщо ми не знаєте про "ptr = NULL". Тоді це виглядатиме так:

![image](https://github.com/user-attachments/assets/ac0d25fb-55db-4988-8d92-bb98189006a4)

## Завдання 5
### Умова
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

### Рішення
Для демонстрації цього випадку, я написала [код](https://github.com/AnastasiiaVdovina/Practice4/blob/main/task5.c). В даному випадку, realloc() не може видлити пам'ять, через те, що ми намагаємося виділити величезний шмат пам'яті, а саме SIZE_MAX. Після того, як realloc() не вдалося виділити пам'ять, ми повинні все одно звільними початковий поінтер, який ми передавали в realloc(). 

![image](https://github.com/user-attachments/assets/0f95c585-346c-4fcf-817f-891354bba722)

## Завдання 6
### Умова
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

### Рішення
Згідно зі стандартом C, виклик realloc(ptr, 0) еквівалентний free(ptr). Це означає, що пам’ять звільняється, і realloc() може або повернути NULL, або вказівник на інший адресний простір (залежно від реалізації).  Як бачимо на скріні нижче, в нашому випадку realloc() повернув не NULL.

![image](https://github.com/user-attachments/assets/6f7b1a3b-5493-405a-aef9-d50d945603cb)

Тому скоріше за все, ми тут ще й стикаємося з проблемою подвійного звільнення пам'яті. Одні проблеми..

Виклик realloc з NULL-поінтером еквівалентний malloc(). Тобто в нашому випадку realloc(NULL, size) ~ malloc(size), що виділяє пам'ять розміром в size байт.

## Завдання 7
### Умова
Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.

### Рішення
Основна відмінність між realloc і reallocarray полягає в тому, що reallocarray допомагає уникнути переповнення цілочисельного типу при обчисленні нового розміру пам’яті.
Тобто realloc не має вбудованого механізму перевірки переповнення, а reallocarray автоматично обробляє цю ситуацію та не допускає виділення неправильного обсягу пам’яті.
Переввіримо результати з ltrace. 
Випадок 1: використання reallocarray():

![image](https://github.com/user-attachments/assets/a7e4a319-8a58-4de9-835c-cbc70bde2a02)

Випадок 2: використання realloc()

![image](https://github.com/user-attachments/assets/b4467120-ad3b-47eb-86e5-7f03866fa994)

На основі ltrace логів видно, що reallocarray() і realloc() відрізняються у форматі виклику та безпеці обчислення розміру пам’яті. reallocarray() викликається з додатковими аргументами (500, 4, 227, 0), що вказує на внутрішню перевірку множення, тоді як realloc() приймає лише новий розмір (2000).

## Завдання 8(Індивідуальне завдання)
### Умова
Реалізуйте власну функцію malloc, використовуючи mmap() та brk().

### Рішення
Це завдання в репозиторії має назву [ind_task.c](https://github.com/AnastasiiaVdovina/Practice4/blob/main/ind_task.c).
Спочатку, треба було зрозуміти, що таке brk() та mmap() та як їх правильно використати.
brk() – це системний виклик, який змінює межу сегмента даних процесу. Він використовується для поступового збільшення купи.Це ефективно для невеликих виділень(і це зіграє потім важливу роль), але має обмеження, оскільки пам’ять виділяється послідовно і не може бути легко звільнена окремими блоками.
mmap() – це більш гнучкий механізм, який дозволяє виділяти та звільняти сторінки пам’яті напряму через віртуальну пам’ять. Його часто використовують для великих виділень, бо він не залежить від загального brk() сегмента і дозволяє легко вивільняти блоки.

Отож, в своєму коді я використовувала brk() для невеликих виділень пам'яті, а mmap() - для великих. Як я визначала "великий" чи "невеликий"? Розмір - це соціальний конструкт, тому в якості розмежувальника я використовувала розмір сторінки PAGE_SIZE (4096 байт). 
Загалом програма складається з функції, яка визначає , яка функція буде використовуватись в залежності від розміру переданого аргументу, далі самі обидві ці функції(кастомні malloc() з використанням brk та mmap) та кастомний free(). 
Перевіримо програму на коректність. Спочатку спробуємо виділити трохи пам'яті:

![image](https://github.com/user-attachments/assets/a4319561-0fb3-4d58-bef7-227073a4b794)

А тепер передамо великий аргумент:

![image](https://github.com/user-attachments/assets/4cdbc618-88b8-4261-942a-e0368a0df8ad)

Ця програма вийшла досить функціональною, але вона не передбачає можливість повторного використання пам'яті. Для того, щоб реалізувати тут ще і хороше керування пам'яттю,щоб це повноцінно відповідало malloc(), я поки що не маю достатньої кількості знань, тому думаю, що цей код може бути розширений у майбутньому.

